<!DOCTYPE html>
<html><html><head><script language="JavaScript">
  socket= new WebSocket('ws://localhost:5678/watch-reload');
  socket.onopen= function() {
                           socket.send ('watch') ;
                           };
  socket.onmessage= function(s) {
                               if                                                          ( s.data == 'started') {
                                                                                                                   console.log ("Watching started") ;
                                                                                                                   }                                 else                   if ( s.data == 'reload') {
                                                                                                                                                                                                      console.log            ("reloading") ;
                                                                                                                                                                                                      window.location.reload ()            ;
                                                                                                                                                                                                      } else                   {
                                                                                                                                                                                                                                alert('Don\'t know what to do with [' + s.data + ']');
                                                                                                                                                                                                                                }
                               };
  </script>
  <style type="text/css">body {
    background-image: linear-gradient(0deg, #fff4e8 25%, #fef8e9 25%, #fef8e9 50%, #fff4e8 50%, #fff4e8 75%, #fef8e9 75%, #fef8e9 100%);
    background-size: 32.00px 32.00px;
    color: #3e3c3f;
    font-family: "Source Sans Pro", sans-serif;
    font-size: 14px;
    padding-left: 10px;
    padding-right: 10px;
    margin: 0;
}

.nspin {
    border-radius: 10px;
    background: #d7d2c3;
    padding: 10px;
    margin-bottom: 5px;
}

.nspout {
    border-radius: 10px;
    background: #e4ded0;
    padding: 10px;
    margin-left: 10px;
}

.nspbox {
    padding-bottom: 5px;
    margin: 0;
}

.FAILED { color: #bb0000; }
.PASSED { color: #009500; }

p {
    margin-top: 0;
    margin-bottom: 5px; }

h1, h2, h3, h4, h5, h6 {
    margin-top: 10px;
    margin-bottom: 5px;
    color: #720000;
}

a:visited { color: #5E5E59; }
a:link { color: #720000; }
tr:nth-child(even) { background-color: #e4ded0; }
th { background-color: #d7d2c3; }

</style><script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/lang-clj.js" type="text/javascript"></script><link href="https://cdn.datatables.net/1.10.20/css/jquery.dataTables.min.css" rel="stylesheet" type="text/css"><script src="https://code.jquery.com/jquery-3.4.1.min.js" type="text/javascript"></script><script src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js" type="text/javascript"></script><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css"></head><body><div><h1>clojisr.v1.vrksasana-test</h1><div><i><small><a href="https://github.com/scicloj/clojisr/tree/master/test/clojisr/v1/vrksasana_test.clj">clojisr.v1.vrksasana-test</a> - created by <a href="https://github.com/scicloj/notespace">notespace</a>, Wed Dec 02 20:11:59 CET 2020.</small></i><hr></div><div>Checks: <b class="PASSED">3 PASSED </b><hr></div><div>Table of contents<ul><li><a href="#intro">intro</a></li><li><a href="#glossary">glossary</a></li><li><a href="#basic-demo">basic-demo</a></li><li><a href="#main-notions">main-notions</a></li><li><a href="#suggested-plan">suggested-plan</a></li></ul><hr></div><div class="nspbox"><div><h1>Session management: a suggested method using Vrksasana</h1></div></div><div class="nspbox"><a id="intro"> </a><div><h2>Intro</h2></div></div><div class="nspbox"><div><p>This is an attempt to achieve two goals:</p><ul><li>introduce a new method of session-management to Clojisr, where multiple sessions can be used safely and objects can be refreshed across sessions</li><li>generalize this method, so that it can be used in other contexts (not just R interop)</li></ul><p>To achive this, we temporarily add the namespaces <code>vrksasana.&#42;</code> under the Clojisr code base. This set of namespaces presents some general-purpose protocols and functionality, as well as a specific implementation for R. The implementation relies on some parts of the Clojisr internals.</p><p>If we decide to go with this approach, then we can change the implementation of the main Clojisr API, to use Vrksasana. Vrksasana will thus come as a layer between Clojisr internals and Clojisr API.</p><p>Then, some existing parts of Clojisr will become redundant.</p><p>We use the name <a href='https://en.wikipedia.org/wiki/Vriksasana'>Vrksasana</a>, beause it is about stability and ease with trees.</p></div></div><div class="nspbox"><a id="glossary"> </a><div><h2>Glossary</h2></div></div><div class="nspbox"><div><ul><li><code>ground</code> - a computation backend (like R, Clojure, etc.)</li><li><code>season</code> - a session, a connection, with a specific way to connect and compute (like an Rserve session, a Renjin session, an nREPL connection, etc.)</li><li><code>planting</code> - creating an AST, representing future computation using a specific ground</li><li><code>seedling</code> - the input of planting</li><li><code>tree</code> - the output of planting &ndash; the AST</li><li><code>picking</code> - computing a given tree in a specific season</li><li><code>fruit</code> - the output of picking, containing the whole computational context and the result value</li></ul></div></div><div class="nspbox"><a id="basic-demo"> </a><div><h2>Basic demo</h2></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(require&nbsp;'[notespace.v2.note&nbsp;:refer&nbsp;[check]])</code></div></div><div class="nspbox"><div><h3>Setting the ground</h3></div></div><div class="nspbox"><div><p>Let us require the main Vrksasana namespace</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(require&nbsp;'[vrksasana.core&nbsp;:as&nbsp;v])</code></div></div><div class="nspbox"><div><p>.. and the main namespace of the Vrksasana implementation for R.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(require&nbsp;'[vrksasana.impl.r.core&nbsp;:as&nbsp;r])</code></div></div><div class="nspbox"><div><p>As we will see, the central notion of Vrksasana is a <code>tree</code>. A tree represents potential computation, based on its <code>AST</code> (Abstract Syntax Tree).</p><p>Trees grow in the ground. More precisely, they grow in a <code>ground</code>. There can be different grounds, and the properties of a specific ground determine how trees grow.</p></div></div><div class="nspbox"><div><p>Here we initialize Vrksasana, setting up the default ground to be R.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(v/restart&nbsp;r/ground)</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(class&nbsp;r/ground)</code></div><div class="nspout"><code class="prettyprint lang-clj">vrksasana.impl.r.ground.Ground</code></div></div><div class="nspbox"><div><h3>Planting a tree</h3></div></div><div class="nspbox"><div><p>Now we can do some R computation. To do that, we <code>plant</code> a tree. It is being planted in the default ground that we've just set.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(def&nbsp;tree1&nbsp;(v/plant&nbsp;'(abs&nbsp;(*&nbsp;10&nbsp;~(range&nbsp;-4&nbsp;4)))))</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(class&nbsp;tree1)</code></div><div class="nspout"><code class="prettyprint lang-clj">vrksasana.tree.Tree</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(keys&nbsp;tree1)</code></div><div class="nspout"><code class="prettyprint lang-clj">(:tree-name&nbsp;:ast)</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">tree1</code></div><div class="nspout"><code class="prettyprint lang-clj">{:tree-name&nbsp;"x221c4de5630645e4",</br>&nbsp;:ast</br>&nbsp;[:ast/funcall</br>&nbsp;&nbsp;"abs"</br>&nbsp;&nbsp;[[:ast/parens</br>&nbsp;&nbsp;&nbsp;&nbsp;[:ast/binary-funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*"</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;10]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;-4]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-3]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-2]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-1]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;0]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;1]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;2]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;3])])]]]]}</code></div></div><div class="nspbox"><div><p>We see that the tree has recieved a random name, and that it holds the AST representing the computation that we asked for.</p></div></div><div class="nspbox"><div><p>To plant the tree, we needed a Clojure form. In our example it was <code>'&#40;abs &#40;&#42; 10 &#126;&#40;range -4 4&#41;&#41;&#41;</code>. We called that form a <code>seedling</code>. The rules for interpreting it depend on the ground. For the R ground, these rules are based on the Clojisr rules for code generation.</p></div></div><div class="nspbox"><div><h3>Picking a fruit</h3></div></div><div class="nspbox"><div><p>To actually make the computation happen, we <code>pick</code> a <code>fruit</code> off the tree.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(def&nbsp;fruit1&nbsp;(v/pick&nbsp;tree1))</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(class&nbsp;fruit1)</code></div><div class="nspout"><code class="prettyprint lang-clj">vrksasana.fruit.Fruit</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">fruit1</code></div><div class="nspout"><code class="prettyprint lang-clj">[1]&nbsp;40&nbsp;30&nbsp;20&nbsp;10&nbsp;&nbsp;0&nbsp;10&nbsp;20&nbsp;30</code></div></div><div class="nspbox"><div><p>We see that the fruit holds an actual R object, and is printed as that R object.</p></div></div><div class="nspbox"><div><p>We can convert it to Clojure data.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(->>&nbsp;fruit1</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v/fruit->data</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;=&nbsp;[40&nbsp;30&nbsp;20&nbsp;10&nbsp;0&nbsp;10&nbsp;20&nbsp;30]))</code></div><div class="nspout"><code class="prettyprint lang-clj">[:PASSED&nbsp;[40&nbsp;30&nbsp;20&nbsp;10&nbsp;0&nbsp;10&nbsp;20&nbsp;30]]</code></div></div><div class="nspbox"><div><h3>What does the fruit look like on the inside?</h3></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(keys&nbsp;fruit1)</code></div><div class="nspout"><code class="prettyprint lang-clj">(:season&nbsp;:tree&nbsp;:value)</code></div></div><div class="nspbox"><div><p>The fruit remembers the tree.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(->>&nbsp;fruit1</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:tree</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;=&nbsp;tree1))</code></div><div class="nspout"><code class="prettyprint lang-clj">[:PASSED</br>&nbsp;{:tree-name&nbsp;"x221c4de5630645e4",</br>&nbsp;&nbsp;:ast</br>&nbsp;&nbsp;[:ast/funcall</br>&nbsp;&nbsp;&nbsp;"abs"</br>&nbsp;&nbsp;&nbsp;[[:ast/parens</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/binary-funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*"</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;10]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;-4]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-3]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-2]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;-1]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;0]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;1]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;2]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;3])])]]]]}]</code></div></div><div class="nspbox"><div><p>The fruit also knows the resulting value. In the case of the R ground, it is an <code>RObject</code> of Clojisr.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(->&nbsp;fruit1</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:value</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class)</code></div><div class="nspout"><code class="prettyprint lang-clj">clojisr.v1.robject.RObject</code></div></div><div class="nspbox"><div><h3>Changing seasons</h3></div></div><div class="nspbox"><div><p>The fruit also knows on which season it was picked. The <code>season</code> is a representation of the computational session where things were computed (in this case, it is a Clojisr session, wrapping an Rserve session).</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(def&nbsp;season1&nbsp;(:season&nbsp;fruit1))</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(class&nbsp;season1)</code></div><div class="nspout"><code class="prettyprint lang-clj">vrksasana.impl.r.season.Season</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(keys&nbsp;season1)</code></div><div class="nspout"><code class="prettyprint lang-clj">(:ground&nbsp;:season-name&nbsp;:attributes&nbsp;:session)</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(->&nbsp;season1</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:session</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class)</code></div><div class="nspout"><code class="prettyprint lang-clj">clojisr.v1.impl.rserve.session.RserveSession</code></div></div><div class="nspbox"><div><p>We can pick our fruits on different seasons. In the context of the R ground, this means different R sessions.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(let&nbsp;[data&nbsp;(range&nbsp;4)</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree1&nbsp;(v/plant&nbsp;`(+&nbsp;1&nbsp;~data))</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree2&nbsp;(v/plant&nbsp;`(+&nbsp;2&nbsp;~data))</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;season1&nbsp;(v/get-or-make-season&nbsp;r/ground&nbsp;:s1)</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;season2&nbsp;(v/get-or-make-season&nbsp;r/ground&nbsp;:s2)]</br>&nbsp;&nbsp;&nbsp;{:fruit1&nbsp;(v/pick&nbsp;tree1&nbsp;{:season&nbsp;season1}),</br>&nbsp;&nbsp;&nbsp;&nbsp;:fruit2&nbsp;(v/pick&nbsp;tree2&nbsp;{:season&nbsp;season2})})</code></div><div class="nspout"><code class="prettyprint lang-clj">{:fruit1&nbsp;[1]&nbsp;1&nbsp;2&nbsp;3&nbsp;4</br>,&nbsp;:fruit2&nbsp;[1]&nbsp;2&nbsp;3&nbsp;4&nbsp;5</br>}</code></div></div><div class="nspbox"><div><h3>Fruit mix</h3></div></div><div class="nspbox"><div><p>Trees, fruit and Clojure data can be mixed to create seedlings for new trees.</p></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(def&nbsp;exotic-fruit</br>&nbsp;&nbsp;&nbsp;(let&nbsp;[season1&nbsp;(v/get-or-make-season&nbsp;r/ground&nbsp;:s1)</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;season2&nbsp;(v/get-or-make-season&nbsp;r/ground&nbsp;:s2)</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree1&nbsp;(v/plant&nbsp;'(*&nbsp;1&nbsp;10))</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fruit1&nbsp;(v/pick&nbsp;tree1&nbsp;{:season&nbsp;season1})</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree2&nbsp;(v/plant&nbsp;'(*&nbsp;2&nbsp;100))</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;small-data&nbsp;[3000]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;big-data&nbsp;(range&nbsp;40000&nbsp;40100)</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree&nbsp;(v/plant</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`(+&nbsp;~fruit1&nbsp;~tree2&nbsp;~small-data&nbsp;(min&nbsp;~big-data)&nbsp;500000))]</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v/pick&nbsp;tree&nbsp;{:season&nbsp;season2})))</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(->>&nbsp;exotic-fruit</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v/fruit->data</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;=&nbsp;[543210]))</code></div><div class="nspout"><code class="prettyprint lang-clj">[:PASSED&nbsp;[543210]]</code></div></div><div class="nspbox"><div class="nspin"><code class="prettyprint lang-clj">(set!&nbsp;*print-length*&nbsp;10)&nbsp;(:tree&nbsp;exotic-fruit)</code></div><div class="nspout"><code class="prettyprint lang-clj">{:tree-name&nbsp;"x7786d094300345cf",</br>&nbsp;:ast</br>&nbsp;[:ast/parens</br>&nbsp;&nbsp;[:ast/binary-funcall</br>&nbsp;&nbsp;&nbsp;"+"</br>&nbsp;&nbsp;&nbsp;([:ast/dep</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{:tree-name&nbsp;"xb2c2e8fb10cd4aff",</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ast</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/parens</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/binary-funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*"</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;1]&nbsp;[:ast/integer&nbsp;10])]]}]</br>&nbsp;&nbsp;&nbsp;&nbsp;[:ast/dep</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{:tree-name&nbsp;"x9a305ab0f07045e9",</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ast</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/parens</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/binary-funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*"</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([:ast/integer&nbsp;2]&nbsp;[:ast/integer&nbsp;100])]]}]</br>&nbsp;&nbsp;&nbsp;&nbsp;[:ast/funcall&nbsp;c&nbsp;([:ast/integer&nbsp;3000])]</br>&nbsp;&nbsp;&nbsp;&nbsp;[:ast/funcall</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"min"</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[:ast/dep</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{:tree-name&nbsp;"x2361c36c8baf47f6",</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ast</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:ast/data</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(40000</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40001</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40002</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40003</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40004</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40005</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40006</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40007</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40008</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40009</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)]}]]]</br>&nbsp;&nbsp;&nbsp;&nbsp;[:ast/integer&nbsp;500000])]]}</code></div></div><div class="nspbox"><div><p>We see that a tree's AST holds all dependencies as trees, whenever dependencies come from trees, fruit or big data (on the other hand, small data are included explicitly in the code, following the rules of Clojisr code generation). These dependencies, being trees and not fruits, live across seasons. Thus, we can pick their fruit on any season we wish.</p></div></div><div class="nspbox"><a id="main-notions"> </a><div><h2>Internals</h2></div></div><div class="nspbox"><div><p>Coming soon.</p></div></div><div class="nspbox"><div><h3>Main notions</h3></div></div><div class="nspbox"><div><p>Coming soon.</p></div></div><div class="nspbox"><div><h3>API</h3></div></div><div class="nspbox"><div><p>Coming soon.</p></div></div><div class="nspbox"><div><h3>Code structure</h3></div></div><div class="nspbox"><div><ul><li>The namespaces <code>vrksasana.&#42;</code>, excluding <code>vrksasana.impl.&#42;</code>, are the general part, that is suggested to become a separate library.</li><li><code>vrksasana.impl.r</code> is the implementation of an R ground for Vrksasana. This is the part suggested to remain in Clojisr.</li><li><code>vrsasana.impl.r.season</code> is the only namespace relying on other parts of Clojisr. Note how thin it is, and note that it uses only some parts of Clojisr.</li><li>If we decide to go with this approach, then we can replace the implementation of the main Clojisr API (<code>cloisr.v1.r</code>) to use <code>vrksasana.core</code> and <code>vrksasana.core.impl.r.core</code>. In other words, <code>vrksasana</code> will come as a layer between the existing implementation and the API.</li><li>Then, some existing parts of Clojisr will become redundant. For example, <code>clojisr.v1.codegen</code>, which has been copied and refactored at <code>vrksasana.impl.r.astgen</code>, <code>vrksasana.impl.r.codegen</code>.</li></ul></div></div><div class="nspbox"><div><h3>Implementation</h3></div></div><div class="nspbox"><div><p>Coming soon.</p></div></div><div class="nspbox"><a id="suggested-plan"> </a><div><h2>Suggested plan</h2></div></div><div class="nspbox"><div><h3>Remaining tasks</h3></div></div><div class="nspbox"><div><ul><li>replacing the relevant parts of Clojisr with vrksasana-based parts (should be easy at this stage)</li><li>discuss desired usage patterns and adapt the API</li><li>garbage collection</li><li>Renjin support (almost nothing to do)</li></ul></div></div><div class="nspbox"><div><h3>Future directions</h3></div></div><div class="nspbox"><div><ul><li>separating the general part of vrksasana as a separate library</li><li>caching, serializing fruits across sessions</li><li>generalizing some parts of the R ground AST generation for reuse in other grounds</li><li>other useful grounds (e.g., a Clojure ground supporting <a href='https://github.com/borkdude/sci'>sci</a> and nREPL backends).</li><li>mixing fruit from different grounds in the creation of a tree, computable using data conversions</li></ul></div></div><hr><div>Checks: <b class="PASSED">3 PASSED </b><hr></div><div><i><small><a href="https://github.com/scicloj/clojisr/tree/master/test/clojisr/v1/vrksasana_test.clj">clojisr.v1.vrksasana-test</a> - created by <a href="https://github.com/scicloj/notespace">notespace</a>, Wed Dec 02 20:11:59 CET 2020.</small></i><hr></div></div></body></html></html>